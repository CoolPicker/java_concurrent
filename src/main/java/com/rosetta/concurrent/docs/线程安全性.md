# 线程安全性
要编写线程安全的代码,其核心在于要对状态访问操作进行管理,特别是对共享的(shared)和可变的(mutable)状态的访问.  
同步,包括synchronized(独占的加锁方式),volatile类型的变量,显式锁(Explicit Lock)以及原子变量.  
有三种方式解决多线程访问可变状态变量的问题:  
* 不在线程之间共享该状态变量
* 将状态变量修改为不可变的变量
* 在访问状态变量时使用同步  
## 什么是线程安全性
当多个线程访问某个类时,这个类始终都能表现出正确的行为,那么就称这个类是线程安全的.  
### 竞态条件
Race Condition - 竞态条件. 当某个计算的正确性取决于多个线程的交替执行时序时,就会发生竞态条件.  
最常见的竞态条件类型就是"先检查后执行(check-then-act)"操作,即通过一个可能失效的观测结果来决定下一步的动作.  
为了确保线程安全性,"先检查后执行"(例如延迟初始化)和"读取 - 修改 - 写入"(例如递增运算)等操作必须是原子的.  
上述两种操作统称为复合操作: 包含了一组必须以原子方式执行的操作以确保线程安全性.  
### 内置锁
内置锁(Intrinsic Lock) - 同步代码块(Synchronized Block).同步代码块包括两部分: 一个作为锁的对象引用,一个作为由这个锁保护的代码块.以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块,其中该同步代码块的锁就是方法调用所在的对象.静态的synchronized方法以Class对象作为锁.  
```
synchronized (lock) {
    // 访问或修改由锁保护的共享状态
}
```  
